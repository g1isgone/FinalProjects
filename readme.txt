Reflection CSC 212 Ji Won Chung 

The most challenging aspect of this assignment was to decide the accessor keywords for the fields and the method. I initially set everything in my maze class to static, but I realize that that was probably a bad idea because that would imply all the maze objects would have the same information when we would want separate ones. Therefore, I made some of the keyword as protected and private so the user could not alter information about the maze such as its dimensions and its starting and ending point. Because they were private I created getInfo() functions that would return the information, but not allow the user to change these info.  However, I did make magnify as a static because I wanted all the mazes to have the same magnification. I also made it public so the user could change the scale of the magnification if need be. 

I was also confused to what methods we should make, particularly what manipulators and accessors. I am not sure if I got all the ones that I wanted to, but I based the methods off the fields of my maze class. I tried to make an accessor and manipulator for each field in my maze class, if needed or possible. I realized that some fields would not need a manipulator width and height because I did not want the user to change the dimensions. 

The hardest part about creating the recursion function was thinking about what my cases were and how to return true or false depending on the status of my recursion. Thinking about creating a result variable that would contain the boolean value returned by our north, west, east, south recursion was the hardest part of the recursion function my opinion. 

Another challenging aspect was trying to think about how to integrate all the different classes. Initially, I was creating my own functions and writing complicated codes and pseudocodes because I was not using the other classes and did not know how to use them. Howevr, after reading through each class and thinking about how to make my coding more concise, I replaced most of my code with the more concise version that employed the use of enums. I found out that thinking about all the fields of our class first helped me organize the types of all the data and preplan. 

I also wonder how effective this recursion method is. I wonder if there is a better way to track all the paths that is quicker ( although this one was very quick ) because we seemed to be visiting places that we did not need to. Also, I realized that why my maze solver did work, it did not seem to always choose the optimal path. It would go around the maze or to paths that I personally would not take were I to optimize distance. So I wonder if there is a better algorithm or if we could put more conditions or stop cases that would make our maze not go to places that were not necessary and optimize distance. 

Another thing that I am curious is about is what should we do with the cases where our maze is not necessarily in the right format? I dealt with the case where the first line is an empty line -- I make it do nothing. However, what should we do with the cases where the maze does not have an S nor an F ofr has multiples of each case or texts that don't belong and how would you check those cases? Would we have to create a function that first checks if there is exists only S, F, ., # and then run our maze? 

Overall, I think this was great practice that gave me a better sense of how different classes worked with one another and made me understand the convenience of enums. The part that I wonder about is how efficient my code is. I wonder if there is a conciser way to implement my code. 

